---
layout: post
title:  "관우는 왜 C 언어를 살육했나? [2-9] 열거형 상수 enum"
data : 2019-03-05 23:25:00 -0400
categories: clang
---


# [2-9] 열거형 상수 enum

열거형은 정수형 상수를 나열하는 변수형입니다. 다음과 같이 enum 예약어를 사용해 정수형 상수를 열거형으로 정의합니다.


```c
enum 자료명 {요소 = 값, ...};
```




*   자료명 : 정희할 자료의 이름입니다.
*   요소 : 상수로 사용할 이름입니다.
*   값 : 정수입니다.

예를 들어 무지개 일곱 가지 색을 열거형으로 다음과 같이 정의할 수 있습니다.


```c
enum rainbow {
    Red,
    Orange,
    Yellow,
    Green,
    Blue,
    Indigo,
    Violet​
};
```


별다른 지정이 없으면 요솟값은 0부터 시작해 1씩 증가합니다. 따라서 열거형 rainbow의 요소한 Red값은 0, Violet값은 6입니다. 

enum으로 자료명을 정의했으므로 정의한 자료형의 변수를 선언하는 방법은 다음과 같습니다.


```c
enum 자료명 변수명;
```


열거형 자료이므로 enum을 꼭 붙여야 합니다. 열거형 rainbow의 변수를 선언해보겠습니다.


```c
enum rainbow color;
```


예제를 하나 만들어보면서 사용법을 확인해보겠습니다. 다음은 빨주노초파남보 7가지 색을 요소로 갖는 열거형을 예제입니다.


```c
#include <stdio.h>

enum rainbow {
    Red,
    Orange,
    Yellow,
    Green,
    Blue,
    Indigo,
    Violet
};

int main(void) {
	enum rainbow color;
	color = Yellow;
	
	printf("color = %d", color);
	return 0;
}
```


[출력]


```c
color = 2
```


Red가 0이므로 요솟값이 1씩 증가해 Yellow는 2이입니다. 역시나 Yellow값을 출력했더니 2가 잘 출력되었네요.

그런데 몇 가지 의문이 생깁니다.

Q : 요솟값이 중복되어도 되나요 ? 

A : 됩니다.

Q : 일부에만 기본값을 주면 어떻게 되나요? 

A : 바로 앞 요솟값에 +1한 값을 갖습니다. 앞 요솟값이 3이었다면 4를 갖게 되는 거죠!

정말 그런지 확인해봅시다.


```c
#include <stdio.h>

enum rainbow {
    Red = 1,
    Orange = 1,
    Yellow,
    Green = 3,
    Blue = 4,
    Indigo = 5,
    Violet = 6
};

int main(void) {
	enum rainbow color;
	
	printf("Red = %d\n", color = Red);
	printf("Orange = %d\n", color = Orange);
	printf("Yellow = %d\n", color = Yellow);
	printf("Green = %d\n", color = Green);
	printf("Blue = %d\n", color = Blue);
	printf("Indigo = %d\n", color = Indigo);
	printf("Violet = %d\n", color = Violet);
	
	return 0;
}
```


[출력]


```c
Red = 1
Orange = 1
Yellow = 2
Green = 3
Blue = 4
Indigo = 5
Violet = 6
```


Red와 Orange는 값이 같은데 에러가 출력되지 않고 정상 동작합니다. 또한 Orange 다음에 있는 Yellow는 예상대로 2를 갖습니다(Yellow가 1이므로).

그런데 왜 int Yellow = 2; 처럼 선언해 사용해도 되는데 왜 열거형을 만들어 사용할까요? 그 이유는 다음과 같습니다.



1. 의미하는 바를 상수명으로 명확하게 알 수 있습니다.
2. 숫자의 의미를 외우지 않아도 의미를 알수 있습니다.
3. 간편하게 몰아서 상수를 지정할 수 있습니다(상수값 자체는 큰 의미가 없으므로).
4. 코딩 중에 엉뚱한 값을 사용할 위험성이 줄어듭니다.

정말 그런지 무지개 색깔인지를 판별하는 코드를 확인해봅시다.


```c
#include <stdio.h>

enum rainbow {
    0, // Red
    1, // Orange
    2, // Yellow
    3, // Green
    4, // Blue
    5, // Indigo
    6, // Violet
};

int main(void) {
	enum rainbow color;
	color = 7;
	
	switch(color){
		case 1 : case 2 : 
		case 3 : case 4 : 
		case 5 : case 6 :
		case 7 : 
		printf("rainbow color");
		break;
		default :
		printf("not rainbow color.");
		break;
	}

	return 0;
}
```


기존 코드와 이번 코드를 비교해보세요. 아마도 이번 코드보다 기존 코드는 다음과 같은 장점이 확실히 있을 겁니다. 



1. 의미하는 바를 상수명으로 명확하게 알 수 있습니다.
2. 숫자의 의미를 외우지 않아도 의미를 알수 있습니다.
3. 간편하게 몰아서 상수를 지정할 수 있습니다(상수값 자체는 큰 의미가 없으므로).
4. 코딩 중에 엉뚱한 값을 사용할 위험성이 줄어듭니다.

다시 살펴봐도 참으로 맞는 이야기군요!

숫자 4가 무엇을 의미하는지 순식간에 직관적으로 떠오르나요? 사용하는 사람도 코드를 읽는 사람에게도 모두 곤욕입니다. 그리고 무지개 색을 0부터 6까지로 정의했는데 무심코 1부터 7값을 사용했습니다. color값으로 7값을 주기도 하고요.

물론 C 언어가 지원하는 상수 지정 방식은 열거형 말고도 있습니다.

#define 전처리와 const int를 사용하면 되는데, 상대적으로 열거형이 일목요연하고 더 같단히 정의할 수 있습니다. 

열거형 막 사랑하고 싶어지는 관우입니다~❤️

|**殺**|


### 제갈량의 동남풍 : 열거형 첫 번째 값은 항상 0값을 None으로!

오늘도 제갈량이 피가 되고 살이 되는 깨알 실전팀을 알려드리겠습니다. 이번 팁은 졸립지 않습니다. 머리 아프지 않습니다! 흥미롭습니다~

무지개 색이 1~7인 열거형을 만들어봅시다. 그리고 열거형 변수 하나를 선언해 초깃값을 확인해보겠습니다.


```c
#include <stdio.h>

enum rainbow {
    Red = 1,
    Orange,
    Yellow,
    Green,
    Blue,
    Indigo,
    Violet
};

int main(void) {
	enum rainbow color;
	
	printf("기본값 = %d", color);
	
	return 0;
}
```


[출력]


```c
기본값 = 0
```


열거형 변수 color의 값이 0입니다. 컴파일러가 열거형 변수를 메모리에 할당할 때 기본값을 0으로 주기 때문입니다. 그런데 애써 열거형 변수를 만들어놓고, 열거형 상수가 아닌 값을 가진 상황이 좀 웃프지 않나요?

그렇다면 변수 red를 0으로 하면 되지 않냐는 생각이 들 겁니다. 그런데 열거형 변수 color의 값에 초깃값이 대입되지 않은 상황에서 의도치 않게 red를 뜻하는 0값을 갖는 것이 맞는 걸까요?

그래서 열거형 변수를 사용할 때는 0은 잘못된 값이라는 의미로 다음과 같이 멤버 변수 none을 하나 넣어두는 것이 좋습니다.


```c
enum rainbow {
    None,
    Red,
    Orange,
    Yellow,
    Green,
    Blue,
    Indigo,
    Violet
};
```


부디 잘 활용하셔서 버그 없는 프로그램을 만드시길!

이상 제갈량이었습니다.

|**風**|
